{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reference Documentation rules_synology is still early-days; a lot of this can still change. In many ways, I'm still putting together SPKs that I can check and verify. Toolchains are not all there Some of the targets are a bit fine-grained yet until I can see some usage-patterns that could be optimized by lumping behind some macros. Am I using platforms completely incorrectly? Wondering how a Transition, Aspect, or similar can build for multiple target platforms at once I do appreciate more eyes here. Please submit ideas, gaps, things I have missed, could document, could clarify (broken example repos are helpful). Do connect: my contact info is in the .bcr subdir. Specific Actions docker_project() : Create services using docker-compose files usr_local_linker() : link SPK components to bin, lib, or etc Common Rules images() : define icon info_file() : metadata about the SPK maintainer() : identify the maintainer privilege_config() : SPK privileges protocol_file() : SPK entrypoints / open ports resource_config() service_config() : Services run by the SPK Validation confirm_binary_matches_platform()","title":"Reference Documentation"},{"location":"#reference-documentation","text":"rules_synology is still early-days; a lot of this can still change. In many ways, I'm still putting together SPKs that I can check and verify. Toolchains are not all there Some of the targets are a bit fine-grained yet until I can see some usage-patterns that could be optimized by lumping behind some macros. Am I using platforms completely incorrectly? Wondering how a Transition, Aspect, or similar can build for multiple target platforms at once I do appreciate more eyes here. Please submit ideas, gaps, things I have missed, could document, could clarify (broken example repos are helpful). Do connect: my contact info is in the .bcr subdir.","title":"Reference Documentation"},{"location":"#specific-actions","text":"docker_project() : Create services using docker-compose files usr_local_linker() : link SPK components to bin, lib, or etc","title":"Specific Actions"},{"location":"#common-rules","text":"images() : define icon info_file() : metadata about the SPK maintainer() : identify the maintainer privilege_config() : SPK privileges protocol_file() : SPK entrypoints / open ports resource_config() service_config() : Services run by the SPK","title":"Common Rules"},{"location":"#validation","text":"confirm_binary_matches_platform()","title":"Validation"},{"location":"docs/","text":"Rules data_share docker_project image images info_file maintainer privilege_config protocol_file resource_config service_config systemd_user_unit usr_local_linker Functions confirm_binary_matches_platform docker_compose spk_component data_share load(\"@rules_synology//:defs.bzl\", \"data_share\") data_share( name , permissions , sharename ) A function to define a data-share config that will be copied to the resource of the SPK. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required permissions Permissions on the share. as a dict: {user}:{ro|rw}, {user}:{ro|rw} Dictionary: String -> String optional {} sharename Name of the share; if not given, the rule name will be used. String optional \"\" docker_project load(\"@rules_synology//:defs.bzl\", \"docker_project\") docker_project( name , preload_image , projects ) Configure a collection of Docker Projects The Docker Project is a Worker that carries one or more docker-compose definitions into a Synology NAS, and can be used to turn-up the project defined in the compose files. Each project's name and compose file are represented as a docker_compose() target; these targets are collected in an list projects in a docker_project() target. For example: ( BUILD file) docker_compose( name = \"nginx\" compose = \":dc.yaml\", ) docker_compose( name = \"cryptobot\" compose = \":some_other_compose.yaml\", ) docker_project( name = \"green_stack\", projects = [ \":nginx\", \"cryptobot\" ] ) References: Synology: Docker Project ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required preload_image OCI/Docker image to preload at install of the SPK String optional \"\" projects List of docker_compose() targets to bundle to this project List of labels optional [] image load(\"@rules_synology//:defs.bzl\", \"image\") image( name , src , image , size , verbose ) Create a single resized image from the src image. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required src Initial source image to convert to desired size. Label required image name of target image file. The name should end with a suffix that determines the resulting format: .png, .jpg, .PNG, etc. String optional \"\" size size (length of square bounding box) to convert src to. Integer optional 256 verbose Verbosity can enable some debug messages from //tools:resize that can help resolve errors. Boolean optional False images load(\"@rules_synology//:defs.bzl\", \"images\") images( name , src , images_template , sizes , verbose ) Create a filegroup of resized images: 16x16, 24x24, etc ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required src Initial source image to convert to various sizes. Label required images_template template for output files: use a string with a single {} that will be replaced with the size. The template should end with a suffix that determines the resulting format: .png, .jpg, .PNG, etc. Note that Synology SPK packaging requires files of the form PACKAGE_ICON_ .PNG so changing this should entail converting the result back however desired for the payload of the SPK. String optional \"\" sizes sizes to convert: use a list of ints, each of which is a desired size of a square bounding box. List of integers optional [16, 24, 32, 48, 64, 72, 90, 120, 256] verbose Verbosity can enable some debug messages from //tools:resize that can help resolve errors. Boolean optional False info_file load(\"@rules_synology//:defs.bzl\", \"info_file\") info_file( name , out , arch_strings , beta , ctl_stop , description , displayname , dsmappname , dsmapppage , dsmuidir , maintainer , os_max_ver , os_min_ver , package_name , package_version , silent_install , silent_uninstall , silent_upgrade , support_conf_folder , validation_softfail ) Create an INFO file The INFO file is the simple metadata k/v dict of the SPK: a number of key=value pairs that define attributes of the package. This file is needed to inform the Synology NAS of the name and unique ID of the package, quote maintainers and distributors, and indicate architecture and OS constraints to install. I personally expect that the simple format of this file allows the UI to show install dialogs with minimal complexity. Likely the reader will notice that the maintainer() block collects more information than it needs to for the INFO file: the additional URL is optional, but can help track down a maintainer if a user or collaborator needs to find them. This is not necessarily intended to be the upstream URL(s) of a project (ie github pages, docker URLs,etc) but is intended to be a valid URL that can help precisely identify where the preferred path to find that maintainer. This implementation mimics the defaults from Synology's documentation so that the bare minimum attributes can be provided to unblock immediate progress. Examples ( BUILD file) load(\"@//:defs.bzl\", \"info_file\", \"maintainer\") maintainer( name = \"chickenandpork\", maintainer_name = \"Allan Clark\", maintainer_url = \"http://linkedin.com/in/goldfish\", visibility = [\"//visibility:public\"], ) info_file( name = \"floppydog_info\", package_name = \"FloppyDog\", description = \"Provides the FloppyDog set of CLI tools for Great Justice\", maintainer = \":chickenandpork\", os_min_ver = \"7.0-1\", # correct-format=[^\\d+(\\.\\d+){1,2}(-\\d+){1,2}$] package_version = \"1.0.0-1\", ) The INFO file generated by this looks similar to: package=\"FloppyDog\" version=\"1.0.0-1\" os_min_ver=\"7.0-1\" description=\"Provides the FloppyDog set of CLI tools for Great Justice\" maintainer=\"Allan Clark\" arch=\"noarch\" ctl_stop=\"yes\" startable=\"yes\" thirdparty=\"yes\" info_file() uses maintainer() to carry information about the package's maintainer: referring to a maintainer by target ID allows greatest re-use of a DRY data element, and should allow the author to associate a maintainer globally maintained in a dependency resource: ( MODULE.bazel ) bazel_dep(name = \"firehydrant_stuff\", version = \"1.2.3\") ( BUILD.bazel ) info_file( name = \"firehydrant_info\", package_name = \"FireHydrant\", description = \"A great Incident-Management resource made by SREs for SREs\", maintainer = \"@firehydrant_stuff//maint:robertross\", os_min_ver = \"7.0-1\", # correct-format=[^\\d+(\\.\\d+){1,2}(-\\d+){1,2}$] package_version = \"1.0.0-1\", ) Ref: * Synology: INFO ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out Name of the Info file, if INFO is not preferred (changing this is not recommended). Label ; nonconfigurable optional None arch_strings array of architectures (strings): [ \"alpine\", ...] (default: [\"noarch\"]). List of strings optional [\"noarch\"] beta Mark version as Beta: Package Center will show the Beta marker (may allow filtering?) Boolean optional False ctl_stop Indicates (boolean) whether there is a start-stop-script and the SPK can be started or stopped (previously: startable). Boolean optional True description Brief description of the package: copy-paste from the upstream if permissible. Although this is permitted be a looooong single-line string, it does display on the UIs to install a package, so brevity is still encouraged. String required displayname Human-readable name of the package, should resemble external package name. If blank, package_name is used in Synology UI. String optional \"\" dsmappname Unique identifiers for App in DSM: SYNO.SDS.{name}: ['SYNO.SDS.Music', 'SYNO.SDS.Albums']. List of strings optional [] dsmapppage Application page to open when package 'open' button clicked. Seems that it should be prefixed with one of the dsmappname values: SYNO.SDS.Music.Playlists. String optional \"\" dsmuidir {[linkname:]subdir}: Subdir in the Package.tgz that contains the DSM UI config and content; this will get softlinked as /usr/syno/synoman/webman/3rdparty/{linkname} -> /var/packages/{package name}/target/{subdir}. {linkname} defaults to {package_name}. Multiple values may be given, space-separated: 'MyLinkName1:ui/app1 MyLinkName2:ui/app2'. String optional \"\" maintainer Maintainer of the build logic for the component (primary if multiple, a person) Label required os_max_ver Latest version of DSM that can install the package; ie \"DSM 7.1.1-42962\". \" + \"There seems to be no handling of the extended hard-to-parse suffixes used by \" + \"Synology such as \"DSM 7.1.1-42962 Update 6\". String optional \"\" os_min_ver Earliest version of DSM that can install the package; ie \"DSM 7.1.1-42962\". \" + \"There seems to be no handling of the extended hard-to-parse suffixes used by \" + \"Synology such as \"DSM 7.1.1-42962 Update 6\". String required package_name Name of the package, unique within Synology SPKs, hopefully resembles external package name String required package_version Version of the package; although I recommend semver-ish X.Y.Z-BUILDNUM, Synology describes as being any string of numbers separated by periods, dash, or underscore, but will later fail anything outside the pattern of (0-9]+.){1-5}[-[0-9]+] (essentially 1-5 dot-separated digits with an optional hyphen and number of up to 5 digits: 1.2.3.4.5-56789) String required silent_install If set to 'True', your package is allowed to be installed without the package wizard in the background. Boolean optional False silent_uninstall If set to 'True', your package is allowed to be uninstalled without the package wizard in the background. Boolean optional False silent_upgrade If set to 'True', your package is allowed to be upgraded without the package wizard in the background. Boolean optional False support_conf_folder Was required to indicate that special configs in conf folder would be used. Unnecessary since DSM-6.0 and deprecated. Boolean optional True validation_softfail Redirects fatal validation failures into either debug messages or ignored/unprinted in case of inaccuracy in any validation step, or workarounds, or unittesting. Choice of ['fail', 'message', 'ignored']. This should likely remain the default value. String optional \"fail\" maintainer load(\"@rules_synology//:defs.bzl\", \"maintainer\") maintainer( name , maintainer_name , maintainer_url ) A simple wrapper for re-use and typing, this produces a Maintainer that can be used as an attribute to targets they maintain. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required maintainer_name - String required maintainer_url - String optional \"\" privilege_config load(\"@rules_synology//:defs.bzl\", \"privilege_config\") privilege_config( name , out , groupname , run_as_package , run_as_root , username ) A function (currently stubbed) to define a privilege configuration (conf/privilege) configuring packages installed in Synology. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out - Label ; nonconfigurable optional None groupname posix/unix groupname in which the app-specific user is added String optional \"rules_synology\" run_as_package list of apps/services that sound run-as the given username List of strings optional [] run_as_root list of apps/services that sound run-as root List of strings optional [] username app-specific posix/unix username under which the app/service runs String required protocol_file load(\"@rules_synology//:defs.bzl\", \"protocol_file\") protocol_file( name , out , package_name , service_config ) The Protocol file is used as a wrapper/collector of service_configs: a building-block to generate the actual file as a buildable object for use in a Port Config resource. Format is an INI file, as discussed in the DSM_Developer_Guide_7_enu.pdf, section \"Port\" on p 128 in my copy (search for \"Configure Format Template\"). Effectively, it builds the file that is pointed-to by a port-config.protocol-file entry in a resource JSON file. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out - Label ; nonconfigurable optional None package_name - String optional \"\" service_config - List of labels optional [] resource_config load(\"@rules_synology//:defs.bzl\", \"resource_config\") resource_config( name , resources , out ) A function to define a resource configuration (conf/resource) configuring packages installed in Synology. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required resources - List of labels required out - Label ; nonconfigurable optional None service_config load(\"@rules_synology//:defs.bzl\", \"service_config\") service_config( name , description , dst_ports , port_forward , src_ports , title ) A function to define a service configuration (port-forward) for a package installed on Synology ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required description - String required dst_ports - String required port_forward - Boolean optional True src_ports - String optional \"\" title - String required systemd_user_unit load(\"@rules_synology//:defs.bzl\", \"systemd_user_unit\") systemd_user_unit( name ) Configure a /usr/local Linker The Systemd User Unit is a Worker that triggers the install process to make available the systemd unit(s) in conf/systemd/pkguser-<name> into home/.config/systemd/user/ during postinst, removing during postuninst. The package should then use synosystemctl start and synosystemctl stop to control the service inside scripts (which should include the SSS script). Example This will cause a system user unit module to be copied from conf/systemd/pkguser-awesomesauce to home/.config/systemd/user/ so that the postinst step can trigger synosystemctl start in an SSS script run during postinst stage (including the enclosing wrappers for clarity): load(\"@//:defs.bzl\", \"resource_config\", \"systemd_user_unit\") systemd_user_unit( name = \"systemd-awesome\", ) ... resource_config( name = \"rez\", resources = [ ... \":systemd-awesome\" ], ) pkg_files( name = \"conf\", srcs = [ ... \":rez\" ], prefix = \"conf\", ) pkg_tar( name = \"awesomesauce\", srcs = [ ... \":conf\" ], ], extension = \"tar\", package_file_name = \"awesomesauce.spk\", ) References: Synology: Systemd User Unit ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required usr_local_linker load(\"@rules_synology//:defs.bzl\", \"usr_local_linker\") usr_local_linker( name , bin , etc , lib ) Configure a /usr/local Linker The /usr/local linker is a Worker that softlinks payload binaries, libraries, and config files to bin, lib, and etc subdirectories in /usr/local on package start and removes on package stop. If the link or file pre-exists, /usr/local worker will unlink() those files, effectively overwriting. Any failure to pre-delete or create a link results in the process failing, triggering any rollback. Example This will cause a softlink to be created in /usr/local/bin that points to /var/packages/<package>/target/bin/netfilter-mods : load(\"@//:defs.bzl\", \"usr_local_linker\") usr_local_linker( name = \"softlinks\", bin = [\"netfilter-mods\"], ) There is currently no method of linking to a target with a different name: the underlying config that Synology doesn't offer that capability. References: Synology: /usr/local linker ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required bin binary paths to softlink into /usr/local/bin List of strings optional [] etc configfile paths to softlink into /usr/local/etc List of strings optional [] lib library paths to softlink into /usr/local/lib List of strings optional [] confirm_binary_matches_platform load(\"@rules_synology//:defs.bzl\", \"confirm_binary_matches_platform\") confirm_binary_matches_platform( binary , size ) PARAMETERS Name Description Default Value binary - none size - \"small\" docker_compose load(\"@rules_synology//:defs.bzl\", \"docker_compose\") docker_compose( name , compose , project_name , path , debug ) Configure a single Docker Project (a docker-compose) The Docker Project is a Worker that carries one or more docker-compose definitions into a Synology NAS, and can be used to turn-up the project defined in the compose files. The Synology Docker Project Worker expects a name and a compose file for each project. docker_compose() is used to provide a name/compose pair, which are then collected in a docker_project() target: ( BUILD file) docker_compose( name = \"nginx\" compose = \":dc.yaml\", ) docker_compose( name = \"cryptobot\" compose = \":some_other_compose.yaml\", ) docker_project( name = \"green_stack\", projects = [ \":nginx\", \"cryptobot\" ] ) References: Synology: Docker Project PARAMETERS Name Description Default Value name - none compose - none project_name - None path - None debug - False spk_component load(\"@rules_synology//:defs.bzl\", \"spk_component\") spk_component( name , spk , filename ) Pull a member component from the SPK archive for further testing spk_component pulls a component from the SPK file by passing the filename to an unpack; the result should be usable to confirm that the SPK packed up what was expected. PARAMETERS Name Description Default Value name - none spk - none filename - none","title":"Docs"},{"location":"docs/#rules","text":"data_share docker_project image images info_file maintainer privilege_config protocol_file resource_config service_config systemd_user_unit usr_local_linker","title":"Rules"},{"location":"docs/#functions","text":"confirm_binary_matches_platform docker_compose spk_component","title":"Functions"},{"location":"docs/#data_share","text":"load(\"@rules_synology//:defs.bzl\", \"data_share\") data_share( name , permissions , sharename ) A function to define a data-share config that will be copied to the resource of the SPK. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required permissions Permissions on the share. as a dict: {user}:{ro|rw}, {user}:{ro|rw} Dictionary: String -> String optional {} sharename Name of the share; if not given, the rule name will be used. String optional \"\"","title":"data_share"},{"location":"docs/#docker_project","text":"load(\"@rules_synology//:defs.bzl\", \"docker_project\") docker_project( name , preload_image , projects )","title":"docker_project"},{"location":"docs/#configure-a-collection-of-docker-projects","text":"The Docker Project is a Worker that carries one or more docker-compose definitions into a Synology NAS, and can be used to turn-up the project defined in the compose files. Each project's name and compose file are represented as a docker_compose() target; these targets are collected in an list projects in a docker_project() target. For example: ( BUILD file) docker_compose( name = \"nginx\" compose = \":dc.yaml\", ) docker_compose( name = \"cryptobot\" compose = \":some_other_compose.yaml\", ) docker_project( name = \"green_stack\", projects = [ \":nginx\", \"cryptobot\" ] ) References: Synology: Docker Project ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required preload_image OCI/Docker image to preload at install of the SPK String optional \"\" projects List of docker_compose() targets to bundle to this project List of labels optional []","title":"Configure a collection of Docker Projects"},{"location":"docs/#image","text":"load(\"@rules_synology//:defs.bzl\", \"image\") image( name , src , image , size , verbose ) Create a single resized image from the src image. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required src Initial source image to convert to desired size. Label required image name of target image file. The name should end with a suffix that determines the resulting format: .png, .jpg, .PNG, etc. String optional \"\" size size (length of square bounding box) to convert src to. Integer optional 256 verbose Verbosity can enable some debug messages from //tools:resize that can help resolve errors. Boolean optional False","title":"image"},{"location":"docs/#images","text":"load(\"@rules_synology//:defs.bzl\", \"images\") images( name , src , images_template , sizes , verbose ) Create a filegroup of resized images: 16x16, 24x24, etc ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required src Initial source image to convert to various sizes. Label required images_template template for output files: use a string with a single {} that will be replaced with the size. The template should end with a suffix that determines the resulting format: .png, .jpg, .PNG, etc. Note that Synology SPK packaging requires files of the form PACKAGE_ICON_ .PNG so changing this should entail converting the result back however desired for the payload of the SPK. String optional \"\" sizes sizes to convert: use a list of ints, each of which is a desired size of a square bounding box. List of integers optional [16, 24, 32, 48, 64, 72, 90, 120, 256] verbose Verbosity can enable some debug messages from //tools:resize that can help resolve errors. Boolean optional False","title":"images"},{"location":"docs/#info_file","text":"load(\"@rules_synology//:defs.bzl\", \"info_file\") info_file( name , out , arch_strings , beta , ctl_stop , description , displayname , dsmappname , dsmapppage , dsmuidir , maintainer , os_max_ver , os_min_ver , package_name , package_version , silent_install , silent_uninstall , silent_upgrade , support_conf_folder , validation_softfail )","title":"info_file"},{"location":"docs/#create-an-info-file","text":"The INFO file is the simple metadata k/v dict of the SPK: a number of key=value pairs that define attributes of the package. This file is needed to inform the Synology NAS of the name and unique ID of the package, quote maintainers and distributors, and indicate architecture and OS constraints to install. I personally expect that the simple format of this file allows the UI to show install dialogs with minimal complexity. Likely the reader will notice that the maintainer() block collects more information than it needs to for the INFO file: the additional URL is optional, but can help track down a maintainer if a user or collaborator needs to find them. This is not necessarily intended to be the upstream URL(s) of a project (ie github pages, docker URLs,etc) but is intended to be a valid URL that can help precisely identify where the preferred path to find that maintainer. This implementation mimics the defaults from Synology's documentation so that the bare minimum attributes can be provided to unblock immediate progress.","title":"Create an INFO file"},{"location":"docs/#examples","text":"( BUILD file) load(\"@//:defs.bzl\", \"info_file\", \"maintainer\") maintainer( name = \"chickenandpork\", maintainer_name = \"Allan Clark\", maintainer_url = \"http://linkedin.com/in/goldfish\", visibility = [\"//visibility:public\"], ) info_file( name = \"floppydog_info\", package_name = \"FloppyDog\", description = \"Provides the FloppyDog set of CLI tools for Great Justice\", maintainer = \":chickenandpork\", os_min_ver = \"7.0-1\", # correct-format=[^\\d+(\\.\\d+){1,2}(-\\d+){1,2}$] package_version = \"1.0.0-1\", ) The INFO file generated by this looks similar to: package=\"FloppyDog\" version=\"1.0.0-1\" os_min_ver=\"7.0-1\" description=\"Provides the FloppyDog set of CLI tools for Great Justice\" maintainer=\"Allan Clark\" arch=\"noarch\" ctl_stop=\"yes\" startable=\"yes\" thirdparty=\"yes\" info_file() uses maintainer() to carry information about the package's maintainer: referring to a maintainer by target ID allows greatest re-use of a DRY data element, and should allow the author to associate a maintainer globally maintained in a dependency resource: ( MODULE.bazel ) bazel_dep(name = \"firehydrant_stuff\", version = \"1.2.3\") ( BUILD.bazel ) info_file( name = \"firehydrant_info\", package_name = \"FireHydrant\", description = \"A great Incident-Management resource made by SREs for SREs\", maintainer = \"@firehydrant_stuff//maint:robertross\", os_min_ver = \"7.0-1\", # correct-format=[^\\d+(\\.\\d+){1,2}(-\\d+){1,2}$] package_version = \"1.0.0-1\", ) Ref: * Synology: INFO ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out Name of the Info file, if INFO is not preferred (changing this is not recommended). Label ; nonconfigurable optional None arch_strings array of architectures (strings): [ \"alpine\", ...] (default: [\"noarch\"]). List of strings optional [\"noarch\"] beta Mark version as Beta: Package Center will show the Beta marker (may allow filtering?) Boolean optional False ctl_stop Indicates (boolean) whether there is a start-stop-script and the SPK can be started or stopped (previously: startable). Boolean optional True description Brief description of the package: copy-paste from the upstream if permissible. Although this is permitted be a looooong single-line string, it does display on the UIs to install a package, so brevity is still encouraged. String required displayname Human-readable name of the package, should resemble external package name. If blank, package_name is used in Synology UI. String optional \"\" dsmappname Unique identifiers for App in DSM: SYNO.SDS.{name}: ['SYNO.SDS.Music', 'SYNO.SDS.Albums']. List of strings optional [] dsmapppage Application page to open when package 'open' button clicked. Seems that it should be prefixed with one of the dsmappname values: SYNO.SDS.Music.Playlists. String optional \"\" dsmuidir {[linkname:]subdir}: Subdir in the Package.tgz that contains the DSM UI config and content; this will get softlinked as /usr/syno/synoman/webman/3rdparty/{linkname} -> /var/packages/{package name}/target/{subdir}. {linkname} defaults to {package_name}. Multiple values may be given, space-separated: 'MyLinkName1:ui/app1 MyLinkName2:ui/app2'. String optional \"\" maintainer Maintainer of the build logic for the component (primary if multiple, a person) Label required os_max_ver Latest version of DSM that can install the package; ie \"DSM 7.1.1-42962\". \" + \"There seems to be no handling of the extended hard-to-parse suffixes used by \" + \"Synology such as \"DSM 7.1.1-42962 Update 6\". String optional \"\" os_min_ver Earliest version of DSM that can install the package; ie \"DSM 7.1.1-42962\". \" + \"There seems to be no handling of the extended hard-to-parse suffixes used by \" + \"Synology such as \"DSM 7.1.1-42962 Update 6\". String required package_name Name of the package, unique within Synology SPKs, hopefully resembles external package name String required package_version Version of the package; although I recommend semver-ish X.Y.Z-BUILDNUM, Synology describes as being any string of numbers separated by periods, dash, or underscore, but will later fail anything outside the pattern of (0-9]+.){1-5}[-[0-9]+] (essentially 1-5 dot-separated digits with an optional hyphen and number of up to 5 digits: 1.2.3.4.5-56789) String required silent_install If set to 'True', your package is allowed to be installed without the package wizard in the background. Boolean optional False silent_uninstall If set to 'True', your package is allowed to be uninstalled without the package wizard in the background. Boolean optional False silent_upgrade If set to 'True', your package is allowed to be upgraded without the package wizard in the background. Boolean optional False support_conf_folder Was required to indicate that special configs in conf folder would be used. Unnecessary since DSM-6.0 and deprecated. Boolean optional True validation_softfail Redirects fatal validation failures into either debug messages or ignored/unprinted in case of inaccuracy in any validation step, or workarounds, or unittesting. Choice of ['fail', 'message', 'ignored']. This should likely remain the default value. String optional \"fail\"","title":"Examples"},{"location":"docs/#maintainer","text":"load(\"@rules_synology//:defs.bzl\", \"maintainer\") maintainer( name , maintainer_name , maintainer_url ) A simple wrapper for re-use and typing, this produces a Maintainer that can be used as an attribute to targets they maintain. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required maintainer_name - String required maintainer_url - String optional \"\"","title":"maintainer"},{"location":"docs/#privilege_config","text":"load(\"@rules_synology//:defs.bzl\", \"privilege_config\") privilege_config( name , out , groupname , run_as_package , run_as_root , username ) A function (currently stubbed) to define a privilege configuration (conf/privilege) configuring packages installed in Synology. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out - Label ; nonconfigurable optional None groupname posix/unix groupname in which the app-specific user is added String optional \"rules_synology\" run_as_package list of apps/services that sound run-as the given username List of strings optional [] run_as_root list of apps/services that sound run-as root List of strings optional [] username app-specific posix/unix username under which the app/service runs String required","title":"privilege_config"},{"location":"docs/#protocol_file","text":"load(\"@rules_synology//:defs.bzl\", \"protocol_file\") protocol_file( name , out , package_name , service_config ) The Protocol file is used as a wrapper/collector of service_configs: a building-block to generate the actual file as a buildable object for use in a Port Config resource. Format is an INI file, as discussed in the DSM_Developer_Guide_7_enu.pdf, section \"Port\" on p 128 in my copy (search for \"Configure Format Template\"). Effectively, it builds the file that is pointed-to by a port-config.protocol-file entry in a resource JSON file. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required out - Label ; nonconfigurable optional None package_name - String optional \"\" service_config - List of labels optional []","title":"protocol_file"},{"location":"docs/#resource_config","text":"load(\"@rules_synology//:defs.bzl\", \"resource_config\") resource_config( name , resources , out ) A function to define a resource configuration (conf/resource) configuring packages installed in Synology. ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required resources - List of labels required out - Label ; nonconfigurable optional None","title":"resource_config"},{"location":"docs/#service_config","text":"load(\"@rules_synology//:defs.bzl\", \"service_config\") service_config( name , description , dst_ports , port_forward , src_ports , title ) A function to define a service configuration (port-forward) for a package installed on Synology ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required description - String required dst_ports - String required port_forward - Boolean optional True src_ports - String optional \"\" title - String required","title":"service_config"},{"location":"docs/#systemd_user_unit","text":"load(\"@rules_synology//:defs.bzl\", \"systemd_user_unit\") systemd_user_unit( name )","title":"systemd_user_unit"},{"location":"docs/#configure-a-usrlocal-linker","text":"The Systemd User Unit is a Worker that triggers the install process to make available the systemd unit(s) in conf/systemd/pkguser-<name> into home/.config/systemd/user/ during postinst, removing during postuninst. The package should then use synosystemctl start and synosystemctl stop to control the service inside scripts (which should include the SSS script).","title":"Configure a /usr/local Linker"},{"location":"docs/#example","text":"This will cause a system user unit module to be copied from conf/systemd/pkguser-awesomesauce to home/.config/systemd/user/ so that the postinst step can trigger synosystemctl start in an SSS script run during postinst stage (including the enclosing wrappers for clarity): load(\"@//:defs.bzl\", \"resource_config\", \"systemd_user_unit\") systemd_user_unit( name = \"systemd-awesome\", ) ... resource_config( name = \"rez\", resources = [ ... \":systemd-awesome\" ], ) pkg_files( name = \"conf\", srcs = [ ... \":rez\" ], prefix = \"conf\", ) pkg_tar( name = \"awesomesauce\", srcs = [ ... \":conf\" ], ], extension = \"tar\", package_file_name = \"awesomesauce.spk\", ) References: Synology: Systemd User Unit ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required","title":"Example"},{"location":"docs/#usr_local_linker","text":"load(\"@rules_synology//:defs.bzl\", \"usr_local_linker\") usr_local_linker( name , bin , etc , lib )","title":"usr_local_linker"},{"location":"docs/#configure-a-usrlocal-linker_1","text":"The /usr/local linker is a Worker that softlinks payload binaries, libraries, and config files to bin, lib, and etc subdirectories in /usr/local on package start and removes on package stop. If the link or file pre-exists, /usr/local worker will unlink() those files, effectively overwriting. Any failure to pre-delete or create a link results in the process failing, triggering any rollback.","title":"Configure a /usr/local Linker"},{"location":"docs/#example_1","text":"This will cause a softlink to be created in /usr/local/bin that points to /var/packages/<package>/target/bin/netfilter-mods : load(\"@//:defs.bzl\", \"usr_local_linker\") usr_local_linker( name = \"softlinks\", bin = [\"netfilter-mods\"], ) There is currently no method of linking to a target with a different name: the underlying config that Synology doesn't offer that capability. References: Synology: /usr/local linker ATTRIBUTES Name Description Type Mandatory Default name A unique name for this target. Name required bin binary paths to softlink into /usr/local/bin List of strings optional [] etc configfile paths to softlink into /usr/local/etc List of strings optional [] lib library paths to softlink into /usr/local/lib List of strings optional []","title":"Example"},{"location":"docs/#confirm_binary_matches_platform","text":"load(\"@rules_synology//:defs.bzl\", \"confirm_binary_matches_platform\") confirm_binary_matches_platform( binary , size ) PARAMETERS Name Description Default Value binary - none size - \"small\"","title":"confirm_binary_matches_platform"},{"location":"docs/#docker_compose","text":"load(\"@rules_synology//:defs.bzl\", \"docker_compose\") docker_compose( name , compose , project_name , path , debug )","title":"docker_compose"},{"location":"docs/#configure-a-single-docker-project-a-docker-compose","text":"The Docker Project is a Worker that carries one or more docker-compose definitions into a Synology NAS, and can be used to turn-up the project defined in the compose files. The Synology Docker Project Worker expects a name and a compose file for each project. docker_compose() is used to provide a name/compose pair, which are then collected in a docker_project() target: ( BUILD file) docker_compose( name = \"nginx\" compose = \":dc.yaml\", ) docker_compose( name = \"cryptobot\" compose = \":some_other_compose.yaml\", ) docker_project( name = \"green_stack\", projects = [ \":nginx\", \"cryptobot\" ] ) References: Synology: Docker Project PARAMETERS Name Description Default Value name - none compose - none project_name - None path - None debug - False","title":"Configure a single Docker Project (a docker-compose)"},{"location":"docs/#spk_component","text":"load(\"@rules_synology//:defs.bzl\", \"spk_component\") spk_component( name , spk , filename ) Pull a member component from the SPK archive for further testing spk_component pulls a component from the SPK file by passing the filename to an unpack; the result should be usable to confirm that the SPK packed up what was expected. PARAMETERS Name Description Default Value name - none spk - none filename - none","title":"spk_component"},{"location":"glossary/","text":"Glossary Worker (Synology Term) During SPK installation or removal, \"workers\" read a configuration block to see what actions need to be performed. For example: a /usr/local worker maintains softlinks in /usr/local a Docker Project Worker runs multi-container services using one or more docker-compose projects","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#worker","text":"(Synology Term) During SPK installation or removal, \"workers\" read a configuration block to see what actions need to be performed. For example: a /usr/local worker maintains softlinks in /usr/local a Docker Project Worker runs multi-container services using one or more docker-compose projects","title":"Worker"}]}